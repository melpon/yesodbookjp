<h1>Shakespeare テンプレート

<p>Yesod は Shakespeare ファミリーを使っている。これは HTML, CSS, JavaScript を生成するためのテンプレート言語である。この言語ファミリーは、全体的に共通の構文になっている。

<p>これらのテンプレート言語には以下の特徴がある。
<ul>
  <li>コンテンツの正当性を、コンパイル時に保証する
  <li>厳密な型安全性で、XSS アタックを防止する
  <li>型安全なURLで、可能な場所では常に自動的に有効なURLであることをチェックする、

<p>これらのテンプレート言語はもちろん、Yesodとは無関係に、単独で使うことができる。

<h2>概要

<p>Hamlet と Cassius は両方、ネストのためにインデントを使用する whitespace-sensitive フォーマットである。Lucius は、Cassius とはまた別の構文で、CSS のスーパーセットとして使えるようになっている。Julius は単純に JavaScript に変数補完を加えただけの言語である。

<dl>
  <dt>Hamlet (HTML)
  <dd>
    <pre>#{code1}
<dl>
  <dt>Cassius (CSS)
  <dd>
    <pre>#{code2}
<dl>
  <dt>Lucius (CSS)
  <dd>
    <pre>#{code3}
<dl>
  <dt>Julius (JavaScript)
  <dd>
    <pre>#{code4}

<h2>型

<p>型は XSS アタックから守ってくれる。例えば以下のような、何らかの名前を表示する HTML テンプレートを持っていたとする。
<pre>#{code5}
<aside>&#035;{...} は Shakespeare の変数補完である。

<p>name が String 型や Text 型だった場合は、単にテキストをそのまま埋め込むだけでなく、"&lt;"を"&amp;lt;"にするといったエンティティエンコードを行なう。エンコードを行いたくない場合は preEscaped ファミリーの関数を使う。

<p>
  詳細に言えば、<code>&#035;{...}</code> に入れる型は ToHtml 型クラスのインスタンスでなければならない。
  ToHtml 型クラスは、Html 型を生成する toHtml 関数を持っている。
  ToHtml 型クラスのインスタンスである String や Text は、toHtml 関数内で文字列のエスケープを行った上で Html に変換する。
  preEscaped ファミリーの関数は、エスケープを行なわずに Html に変換する関数である。
  Html も ToHtml 型クラスのインスタンスであり、toHtml 内では何も行なわない(<code>toHtml = id</code>)。

<aside>
  これらの型や関数は全て
  <a href="http://hackage.haskell.org/package/blaze-html">blaze-html
  パッケージに入っている。
  Hamlet は blaze-html 同士を相互に作用させ、blaze-html の値を生成するための一般的なソリューションになっている。
  また、blaze-html の素晴らしいパフォーマンスのアドバンテージが得られる。

<p>
  Html/ToHtml と同様に、Css/ToCss や Javascript/ToJavascript もある。
  HTML と違い、CSS や JavaScript はユーザの入力を組み込むことはほとんど無いため、XSS アタックを防ぐことが主目的というわけではない。
  これらの主目的は、CSS に HTML を渡したりしていないかといった正当性のチェックを、コンパイル時に行なうことである。

<aside>
  CSS にはもう一つ、色と単位のためのデータ型が用意されているというアドバンテージもある。
  この機能はここでは特に説明していないので、ドキュメントを探し、自分で試してみることを勧める。

<h2>型安全URL

<p>
  Yesodにあるユニークな機能の一つに、型安全 URL がある。
  Shakespeare テンプレートでは、&#035; を使う代わりに &#064; を使うだけで、型安全 URL を組み込むことができる。
  シンタックスの詳細については後で説明するとして、まずは直感的な動作というものについて明確にしていく。

<!--
http://example.com/profile/home がホームページで、 http://example.com/display/time は現在の時間を表示する、そのような２つのルートを持つアプリケーションがあると仮定する。
ホームページから time のページへリンクしたいとき、URL を構築する３つの選択肢があると考えられる。
- 相対リンク: ../display/time
- 絶対リンク、ドメイン抜き: /display/time
- 絶対リンク、ドメイン有り: http://example.com/display/time

それぞれのアプローチには問題がある。
最初の方法は、どちらかの URL を変更すると壊れる。この方法は、全てのケースにおいて不向きである。例えば RSS と Atom フィードは絶対 URL を要求する。
２番目の方法は、最初の方法よりは URL の変更に強い。しかしまだ RSS と Atom フィードを使用可能にできない。
そして３番目の方法が全てのケースで動作している間、ドメイン名が変化するときは常にアプリケーションの全てのシングル URL をアップデートする必要がある。
You think that doesn't happen often?
あなたの開発がスタンディングかつ最終の製品サーバに移行するまで待って欲しい。

しかしもっと重要なのは、全てのアプローチにある大きな問題を抱えているということだ。
もしどれかのルートを変更しても、コンパイラはリンクが壊れていることを全く警告しない。
タイポによって URL がめちゃめちゃになっても、何も言及しない。

型安全 URL のゴールは、可能な限り URL をコンパイラにチェックさせることだ。
それを手助けするために、我々の最初のステップは、コンパイラの理解出来ないプレーンオールドテキストから離れ、うまく定義されたデータ型に移行しなければならない。
我々のシンプルなアプリケーションのために、直和型でルートをモデル化してみよう
{{{
data MyRoute = Home | Time
}}}

Time コンストラクタを使うことで、 /display/time のようなリンクを置き換えている。
しかし最終的には、HTML はデータ型ではなくテキストを作るため、何らかの方法で値をテキストに変換する必要がある。
我々はこれを URL レンダリング関数と読んでいる。
簡単な実装は次のようになる。
{{{
renderMyRoute :: MyRoute -> Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"
}}}

URL レンダリング関数は、実際にはこれよりもっと複雑である。
これらは、クエリ文字列パラメータに取り組むことを必要とする。クエリ文字列はコンストラクタと共にレコードをハンドルし、もっと賢くドメイン名をハンドルする。
しかしこの練習では、そのようなことを心配する必要は無い。
Yesod はレンダリング関数を自動的に生成する。
ポイントは、実際にクエリ文字列をハンドルするために型シグネチャが少し複雑になっていることである。
{{{
type Query = [(Text, Text)]
type Render url = url -> Query -> Text
renderMyRoute :: Render MyRoute
renderMyRoute Home _ = ...
renderMyRoute Time _ = ...
}}}
OK、我々はレンダリング関数を手に入れ、テンプレートに組み込む型安全 URL を手に入れた。
どのようにこれを使えばいいだろうか。
HTML (あるいは CSS, JavaScript) 値を直接生成する代わりに、Shakespeare テンプレートは、レンダリング関数を受け取ってHTMLを生成する関数を生成する。
これが優れたものであることを確認するため、Hamlet の裏側がどのように動いているのかを少し覗いてみよう。以下のようなテンプレートがあるとする。
{{{
<a href=@{Time}>The time
}}}
これはおおよそ、以下のような Haskell コードに変換する。
{{{
\render -> mconcat ["<a href='", render Time, "'>The time</a>"]
}}}

Syntax

全ての Shakespeare 言語は同じ補完の構文を共有している。そしてそれは型安全 URL を役立たせることができる。
それらは、ターゲットとする言語（HTML, CSS, JavaScript）によって構文が異なる。

Hamlet Syntax

Hamlet は最も洗練された言語だ。
Hamlet は HTML を生成するための構文を提供するだけではない。Hamlet もまた、条件、ループ、maybeといった基本的な制御構造を持っている。
汎用的な Shakespeare テンプレートはロジックを持たない傾向にある。いくつかの制御は練習のために HTML が与えられる。

Tags

当然、タグはどの HTML テンプレート言語であっても重要な部分を占める。
Hamlet では、もっと楽に言語を作るために既存の HTML 構文を stick very close することに挑戦している。
しかしながら、ネストを意味するクローズタグを使う代わりに、インデントを使う。
そのため、HTML で次のようになっているのは、
{{{
<body>
<p>Some paragraph.</p>
<ul>
<li>Item 1</li>
<li>Item 2</li>
</ul>
</body>
}}}
以下のようになる。
{{{
<body>
    <p>Some paragraph.
    <ul>
        <li>Item 1
        <li>Item 2
}}}
一般的に、we find this to be easier to follow than HTML once you get accustomed to it.
トリッキーな部分は、タグの前後に空白文字を入れる場合だけだ。
例えば、以下のような HTML を生成したいとしよう。
{{{
<p>Paragraph <i>italic</i> end.</p>
}}}
"Paragraph" の後ろと "end" の前に空白文字があることを確実にしたいなら、２つのエスケープ文字を使う。
{{{
<p>
    Paragraph #
    <i>italic
    \ end.
}}}
空白文字のエスケープルールは非常にシンプルだ。
- 行にある最初のスペース以外の文字がバックスラッシュなら、バックスラッシュは無視される。
- 業にある最後の文字がハッシュなら、それは無視される。

One other thing.
Hamlet は、そのコンテンツのエンティティをエスケープしない。
これは既存の HTML を簡単に組み込むために使われる。
そのため、上記と同じ動作をさせるなら、以下のように書くことができる。
{{{
<p>Paragraph <i>italic</i> end.
}}}
最初のタグは自動的に閉じられ、その中にある "i" タグはそうならないことに注意しよう。
どちらを選択しても何のペナルティも無いため、どちらのアプローチを使っても構わない。
Be aware, however, that the only time you use closing tags in Hamlet is for such inline tags; normal tags are not closed.

Interpolation

HTML を単純にしたのは素晴らしいが、このままでは Haskell コードと対話することができない。
どのように変数を渡せばいいだろうか。
答えは単純だ。 "補完" を使う。
{{{
<head>
    <title>#{title}
}}}
ハッシュの後ろに２つのブレースで変数補完を意味する。
上記のケースでは、このテンプレートが呼ばれたスコープ内の title 変数が使われる。
Let me state that again: Hamlet は、それが呼ばれたときのスコープにある変数に自動的にアクセスする。
そのため、変数を Hamlet の中に入れることを明確にする必要はない。

だが、それはまだ良くなる。
補完の中で関数を適用することができる。
補完の中で、文字列と数値リテラルを使うことができる。
モジュールを修飾することができる。
両方の括弧とドルマークをグループ文として使うことができる。
最後に、toHtml 関数はその結果に対して適用する。つまり、ToHtmlの全てのインスタンスを補完することができる。

Variable Interpolation

{{{
-- shamlet による準クォートについては今は無視する。
-- それは後で説明する。
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (shamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
<p>Hello, my name is #{name person} and I am #{show $ age person}.
<p>
    Let's do some funny stuff with my name: #
    <b>#{sort $ map toLower (name person)}
<p>Oh, and in 5 years I'll be #{show $ (+) 5 (age person)} years old.
|]
  where
    person = Person "Michael" 26
}}}
¶
我々が大いに宣伝した型安全 URL はどうだろう。
これらは、アットマーク (@) で始まるという部分を除き、あらゆる点でほとんど変数補完と同じに見える。
さらに、同じ型の他のテンプレートを組み込む、キャレット (^) というのもある。

URL Interpolation and Embedding

{{{
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
<footer>
    Return to #
    <a href=@{Home}>Homepage
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
<body>
    <p>This is my page.
    ^{footer}
|] render
}}}

Attributes

¶
あなたが注意を払って見ていたなら、"a" タグに href 属性を置いていたことに気がついていただろう。
この構文は HTML とほとんど同じだが、いくつかのことを明確にしていこう。

- イコールの右側では補完を使うことができる。
- イコールと属性の値は、HTML と同様に省略することができる。そのため <input type=checkbox checked> というは、完全に有効である。
- id と class は便利に記述する方法がある。id はハッシュで、class はピリオドを使う。つまり、<p #paragraphid .class1 .class2> と記述することができる。
- クォートで囲む属性の値がオプショナルであるとき、もしそれに空白を入れたいなら、クォートは必要になる。
- コロン (:) を使うことでオプショナルな属性を追加することができる。変数 isChecked が True であるときだけチェックボックスに checked 属性を付けるために、<input type=checkbox :isChecked:checked> と書くことができる。パラグラフをオプショナルで赤にしたいなら、<p :isRed:style="color:red"> と書くことができる。

Conditionals

最終的には、あなたは自分のページに何らかのロジックを組み込みたいと思うだろう。
Hamlet のゴールは、Haskell 内ではヘビーに lifting し、Hamlet 内では可能な限り最小限のロジックにすることだ。
そのため、我々はロジックを制御する文は本当に基本的なものしか用意していない。if, elseif, else である。

{{{
$if isAdmin
    <p>Welcome to the admin section.
$elseif isLoggedIn
    <p>You are not the administrator.
$else
    <p>I don't know who you are. Please log in so I can decide if you get access.
}}}
条件文の条件は、全て通常の補完と同じルールを適用する。

Maybe

同様に、我々は Maybe 値を扱うための特別な構造を持っている。
これは if, isJust, fromJust を利用することで、技術的には達成される。しかしこれを使うことでもっと便利になり、そして部分関数を回避することができる。

{{{
$maybe name <- maybeName
    <p>Your name is #{name}
$nothing
    <p>I don't know your name.
}}}
<- の左側は単純な識別子でなければならないが、右側は補完と同様に何でも書くことができる。

Forall

リスト上でのループはどうだろうか。
我々はそれもカバーしている。
{{{
$if null people
    <p>No people.
$else
    <ul>
        $forall person <- people
            <li>#{person}
}}}

With

ある文を外に出すために、with がある。
それは基本的に、長い式のシノニムを宣言するときに便利である。

{{{
$with foo <- (一度だけ実行されるべき、とても長くて汚い式)
    <p>しかし私は #{foo} を何度も使うだろう。#{foo}
}}}

Doctype

最後の小さな糖衣構文は、doctype 文だ。
１行に３つのエクスクラメーションマークを並べて使う。
Hamlet はデフォルトでは HTML5 を使うため、生成される doctype は <!DOCTYPE html> である。

{{{
!!!
<html>
    <head>
        <title>Hamlet is Awesome
    <body>
        <p>All done.
}}}

Cassius Syntax

Cassius はオリジナルの CSS テンプレート言語である。
それは単純にブロックを空白で区切る、ブレースとセミコロン不要の言語だ。
それは変数とURLの補完をサポートしているが、組み込みはサポートしていない。
この構文はとても率直だ。

{{{
#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})
}}}


Lucius Syntax

While Cassius uses a modified, whitespace-sensitive syntax for CSS, Lucius is true to the original.
外にある任意の CSS ファイルを、そのまま有効な Lucius ファイルとして取り込むことができる。
ただし Lucius は CSS に対して以下の点が追加されている。

- Cassius のように変数とURL補完を使うことができる。
- CSS ブロックをネストすることができる。
- テンプレート内で変数を宣言することができる。

２番目の点を考慮して書いてみよう。
article タグ内のいくつかのタグに対して特別なスタイルを適用したい場合、プレーンな CSS では以下のように書かなければならなかった。
{{{
article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }
}}}
この場合、多くの節があるわけではないのに article を何度も書かなければならないのが少し面倒だ。
もしこれがダース単位であることを想像して欲しい。
世界で一番最悪というほどではないが、少し苛立たしい。
Lucius はこれを以下のように書くことができる。

{{{
article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}
}}}

Lucius の変数を持つことによって、繰り返しを回避することができる。
単純な例として、共通で使われる色を定義する場合は以下のようにする。

{{{
@textcolor: #ccc; /* just because we hate our users */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }
}}}

あとは、Lucius は CSS と同じである。

Julius Syntax

Julius は、ここで議論した言語の中では一番シンプルだ。
実際、それは言語と言うほどのものではないだろう。
Julius は以前に説明した３つの補完の形式を許可する。そしてそれ以外は何もせず、そのまま出力する。

    もしスカフォードの Yesod サイトで Julius を使ったら、その Javascript が自動的に縮められていることに気がつくだろう。
    これは Julius の機能ではない。代わりに、Yesod が Julius を出力するときに [hjsmin:http://hackage.haskell.org/package/hjsmin]  パッケージを使って縮めている。

Calling Shakespeare

実際に Shakespeare テンプレートをどのように使えばいいのかという疑問が出てくるだろう。
Haskell コードから Shakespeare を呼び出す方法は３つある。

準クォート
    準クォートは Haskell に好きなコンテンツを組み込むことができる。そしてそれはコンパイル時に Haskell コードに変換される。
外部ファイル
    この場合、テンプレートコードは Template Haskell によって参照されるファイルに分けられる。
リロードモード
    上記の両方のモードは何らかの変更があった時に再コンパイルが必要になる。
    リロードモードでは、テンプレートがファイルに分けられ、Template Haskell によって参照されるというのは保持される。しかし、実行時に外部ファイルが書き換えられるたびに再度パースされる。
        リロードモードは Cassius, Lusius, Julius のみ有効で、Hamlet では使えない。
        Hamlet には、Haskell コンパイラによって実行時に再実装可能でない優秀な機能が埋め込まれるためである。

最初の２つのアプローチのどちらかが、実際の製品で使われる。
それらは両方、最終的な実行ファイル内にテンプレートのエンティティが組み込まれる。それは簡単に開発でき、パフォーマンスを増大させる。
準クォートのアドバンテージは、単純であることだ。全て１つのファイル内に収めることができる。
短いテンプレートならこれはよく合う。
しかし一般的に、外部ファイルのアプローチが推奨される。これはなぜかというと、

- 外部ファイルは、伝統的な表現のロジックの分割ができる。
- 外部ファイルとデバッグモードを、単純な CPP マクロで切り替えることができる。つまり、高速に開発しつつ、製品では高いパフォーマンスを発揮することができる。

これらは特別な準クォートと Template Haskell 関数であるため、適切な言語拡張を有効にし、正しい構文を使用することを確認する必要がある。

Quasiquoter
{{{
{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -> HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
<html>
    <head>
        <title>#{title}
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1>#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "My Title" render
}}}
External file
{{{
{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- to control production versus debug
import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render
}}}
{{{
-- @template.lucius
foo { bar: baz }
}}}
¶
関数を表にまとめると、以下のようになる。

| 言語    | 準クォート | 外部ファイル | リロード          |
| Hamlet  | hamlet     | hamletFile   | N/A               |
| Cassius | cassius    | cassiusFile  | cassiusFileReload |
| Lucius  | lucius     | luciusFile   | luciusFileReload  |
| Julius  | julius     | juliusFile   | juliusFileReload  |

Alternate Hamlet Types

これまで、型安全 URL の埋めこまれた Hamlet から HtmlUrl がどのように生成されるかを見てきた。
現在、我々が Hamlet を使って生成することのできる値は３つある。プレーンな HTML, URL と国際化メッセージを含む HTML、ウィジェットの３つである。
最後の１つは widgets チャプターで説明する。

組み込み URL の無いプレーンな HTML を生成するために、我々は "単純化された Hamlet" を使う。
それはいくつかの違いがある。
- 先頭に "s" の付いた、異なる関数セットを使う。そのため、準クォートは shamlet で、外部ファイル関数は shamletFile である。これはどのように発音するかについて、まだ熱い議論が交わされている。
- URL 補完はできない。そうすることによってコンパイルエラーにすることができる。
- 組み込み補完（キャレットによる補完）は、もはや好きな HtmlUrl 値を渡すことができない。このルールは、組み込まれた値がそのテンプレート内で同じ型でなければならない。そのため、この場合は Html でなければならない。 つまり shamlet は、組み込み補完が、通常の変数補完（ハッシュによる補完）に完全に置き換えられる。

¶
国際化（internationalized: i18n）は、通常の Hamlet より少し複雑だ。
これは、型安全URLのコンセプトと実装にとても似ている、メッセージのデータ型のアイデアを基にしている。
サンプルの動機として、我々は、hello と伝え、食べたいリンゴの数を聞くアプリケーションを作りたいとしよう。
我々は、それらのメッセージを表すデータ型を作る。
{{{
data Msg = Hello | Apples Int
}}}
次に、そのデータ型を、人間が読める何かに変換可能にしたいので、以下のレンダリング関数を定義する。
{{{
renderJapanese :: Msg -> Text
renderJapanese Hello = "こんにちは"
renderJapanese (Apples 0) = "あなたはリンゴを買っていない"
renderJapanese (Apples i) = T.concat ["あなたは", T.pack $ show i, "個のリンゴを買った"]
}}}
そして今、我々はテンプレート内で直接、それらの Msg 値を補完したい。
そのためにはアンダースコア補完を使う。
{{{
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
}}}
このテンプレートの種類は、HTML の中にそれらの値を変換するためのいくつかの方法を必要としている。
そのため、型安全URLのように、我々はレンダリング関数を通す。
これを表現するため、我々は新しい型シノニムを定義している。
{{{
type Render url = url -> [(Text, Text)] -> Text
type Translate msg = msg -> Html
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
}}}
重要な点は、あなたはこのテンプレートに renderJapanese, renderEnglish, renderSpanish, renderKligon、あるいはリアルタイムで翻訳する関数（その質はもちろん関数に依存する）を通すことができることである。
完全なサンプルプログラムは以下のようになる。

i18n Example
{{{
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze (toHtml)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -> [(Text, Text)] -> Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderJapanese :: Msg -> Text
renderJapanese Hello = "こんにちは"
renderJapanese (Apples 0) = "あなたはリンゴを買っていない"
renderJapanese (Apples i) = T.concat ["あなたは", T.pack $ show i, "個のリンゴを買った"]

template :: Int -> HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderJapanese) renderUrl
}}}

Other Shakespeare

HTML, CSS, JavaScript のヘルパーに加えて、Shakespeare を有効にする、いくつかのより汎用的なものがある。
shakespeare-text は、Ruby や Python のような慣れたスクリプト言語のように、補完された文字列を生成するための単純な方法を提供する。
このパッケージのユーティリティは当然、Yesod 以外でも使うことができる。
{{{
{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "apples" 5
    , Item "bananas" 10
    ]

main :: IO ()
main = forM_ items $ \item -> TLIO.putStrLn
    [lt|You have #{show $ itemQty item} #{itemName item}.|]
}}}
この単純なサンプルの要点は以下の通りである。
- ３つの異なる、関連したテキストデータ型（String, strict Text, lazy Text）を使っていることに注意。それらは混ぜて使うことができる。
- 準クォートに lt を使うことで、lazy Text を生成する。strict Text を生成する st もある。

General Recommendations

これは、Yesod コミュニティから得られた、Shakespeare を最大限に活かす方法についての一般的なヒントだ。
（もしもっといい方法があるなら、このパラグラフにコメントして欲しい）

- 実際のサイトでは、外部ファイルを使う。ライブラリでは、長すぎないものであれば、準クォートを使っても構わない。
- Patrick Brisbin は、コーディングを楽にする [Vim code highlighter:https://github.com/pbrisbin/html-template-syntax] を使っている。
- あなたはほとんど常に、それぞれの行の最初を Hamlet タグで始め、そのタグの後ろに開始/終了タグを組み込まないでおくべきだ。この例外は、大きなテキストブロック内にある <i> と <b> タグだけだ。
-->
