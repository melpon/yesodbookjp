<h1>Shakespeare テンプレート

<p>Yesod は Shakespeare ファミリーを使っている。これは HTML, CSS, JavaScript を生成するためのテンプレート言語である。この言語ファミリーは、全体的に共通の構文になっている。

<p>これらのテンプレート言語には以下の特徴がある。
<ul>
  <li>コンテンツの正当性を、コンパイル時に保証する
  <li>厳密な型安全性で、XSS アタックを防止する
  <li>型安全なURLで、可能な場所では常に自動的に有効なURLであることをチェックする、

<p>これらのテンプレート言語はもちろん、Yesodとは無関係に、単独で使うことができる。

<h2>概要

<p>Hamlet と Cassius は両方、ネストのためにインデントを使用する whitespace-sensitive フォーマットである。Lucius は、Cassius とはまた別の構文で、CSS のスーパーセットとして使えるようになっている。Julius は単純に JavaScript に変数補間を加えただけの言語である。

<dl>
  <dt>Hamlet (HTML)
  <dd>
    <pre>#{code1}
<dl>
  <dt>Cassius (CSS)
  <dd>
    <pre>#{code2}
<dl>
  <dt>Lucius (CSS)
  <dd>
    <pre>#{code3}
<dl>
  <dt>Julius (JavaScript)
  <dd>
    <pre>#{code4}

<h2>型

<p>型は XSS アタックから守ってくれる。例えば以下のような、何らかの名前を表示する HTML テンプレートを持っていたとする。
<pre>#{code5}
<aside>&#035;{...} は Shakespeare の変数補間である。

<p>name が String 型や Text 型だった場合は、単にテキストをそのまま埋め込むだけでなく、"&lt;"を"&amp;lt;"にするといったエンティティエンコードを行なう。エンコードを行いたくない場合は preEscaped ファミリーの関数を使う。

<p>
  詳細に言えば、<code>&#035;{...}</code> に入れる型は ToHtml 型クラスのインスタンスでなければならない。
  ToHtml 型クラスは、Html 型を生成する toHtml 関数を持っている。
  ToHtml 型クラスのインスタンスである String や Text は、toHtml 関数内で文字列のエスケープを行った上で Html に変換する。
  preEscaped ファミリーの関数は、エスケープを行なわずに Html に変換する関数である。
  Html も ToHtml 型クラスのインスタンスであり、toHtml 内では何も行なわない(<code>toHtml = id</code>)。

<aside>
  これらの型や関数は全て
  <a href="http://hackage.haskell.org/package/blaze-html">blaze-html
  パッケージに入っている。
  Hamlet は blaze-html 同士を相互に作用させ、blaze-html の値を生成するための一般的なソリューションになっている。
  また、blaze-html の素晴らしいパフォーマンスのアドバンテージが得られる。

<p>
  Html/ToHtml と同様に、Css/ToCss や Javascript/ToJavascript もある。
  HTML と違い、CSS や JavaScript はユーザの入力を組み込むことはほとんど無いため、XSS アタックを防ぐことが主目的というわけではない。
  これらの主目的は、CSS に HTML を渡したりしていないかといった正当性のチェックを、コンパイル時に行なうことである。

<aside>
  CSS にはもう一つ、色と単位のためのデータ型が用意されているというアドバンテージもある。
  この機能はここでは特に説明していないので、ドキュメントを探し、自分で試してみることを勧める。

<h2>型安全URL

<p>
  Yesodにあるユニークな機能の一つに、型安全 URL がある。
  Shakespeare テンプレートでは、&#035; を使う代わりに &#064; を使うだけで、型安全 URL を組み込むことができる。
  シンタックスの詳細については後で説明するとして、まずは直感的な動作というものについて明確にしていく。

<p>
  http://example.com/profile/home というページから http://example.com/display/time へのリンクを貼るとき、３つの選択肢がある。

<dl>
  <dt>相対リンク
  <dd>../display/time
<dl>
  <dt>絶対リンク、ドメイン無し
  <dd>/display/time
<dl>
  <dt>絶対リンク、ドメイン有り
  <dd>http://example.com/display/time

<p>
  残念なことに、どの方法にも問題がある。
  最初の方法は、どちらかの URL が変更されると壊れる。
  ２番目の方法は、最初の方法よりは変更に強いが、絶対 URL を要求する RSS や Atom フィードを使用することができない。
  ３番目の方法は、ドメイン名を変えるときに全ての URL を更新する必要がある。

<p>
  もっと重要なのは、全ての方法には、ある共通する大きな問題があるということである。
  それは、リンク先が壊れていることをコンパイラが全く警告できないということだ。
  typo によって URL が壊れたとしても、何も起こらない。

<p>
  型安全 URL のゴールは、可能な限り URL をコンパイラにチェックさせることだ。
  そのために、生テキストではなく、データ型を使う。
  上記の２つのリンクを、直和型でモデル化してみよう

<pre>#{code6}

<p>
  /display/time のようなリンクのために、Time コンストラクタを定義している。
  これでテキストの URL を型で表すことができた。
  しかし最終的にはデータ型ではなくテキストになるため、何らかの方法でデータ型からテキストに変換する必要がある。
  この変換を行なう関数のことを URL レンダリング関数と呼ぶ。
  簡易的な実装は次のようになる。

<pre>#{code7}

<p>
  実際にはクエリ文字列を引数に取るため、次のようになる。

<pre>#{code8}

<p>
  この実装を覚えておく必要は無い。Yesod はレンダリング関数を自動的に生成するからだ。
  ここで覚えておく必要があるのは、クエリ文字列も引数に取っているということだけである。

<p>
  ここまでで、レンダリング関数と型安全 URL が出てきたが、これらをどのように使えばいいだろうか。
  Shakespeare テンプレートは、HTML (あるいは CSS, JavaScript) を直接生成しない。
  代わりに、レンダリング関数を渡すと HTML を生成してくれる関数を作る。
  具体的には、Hamlet は次のようなテンプレートがあるとき、

<pre>#{code9}

<p>
  以下のような Haskell コードに変換する。

<pre>#{code10}

<h2>構文

<p>補間の構文は、すべての Shakespeare テンプレートで同じである。ただし、当然 HTML, CSS, JavaScript の、それぞれの言語特有の構文については異なる。

<h3>Hamletの構文

<p>
  Hamlet は単純に HTML を生成する構文を提供するだけでなく、条件やループ、maybeといった基本的な構造の制御も行なう。
  汎用的な Shakespeare テンプレートはロジックを持たない傾向にあるが、実用目的のために構造制御を一部だけ加えている。

<h4>タグ

<p>
  Hamlet のタグは、既存の HTML 構文に近くなるようにしている。
  ただしネストについては、終了タグの代わりにインデントを使う。
  そのため次のような HTML は、

<pre>#{code11}

<p>以下のようになる。

<pre>#{code12}

<p>
  慣れればこちらの方が簡単だと感じるようになるだろう。
  トリッキーな部分は、タグの前後に空白文字を入れる場合だけだ。
  例えば以下のような HTML を生成したいとする。

<pre>#{code13}

<p>"Paragraph" の後ろと "end" の前にそれぞれ空白文字を入れたいなら、２種類のエスケープ文字を使う。

<pre>#{code14}

<p>空白文字のエスケープルールは非常にシンプルだ。

<ol>
  <li>行頭のスペース以外の文字がバックスラッシュなら、バックスラッシュは無視される。
  <li>行末の文字がハッシュなら、ハッシュは無視される。

<p>
  また、Hamlet はコンテンツのエンティティをエスケープしない。
  これは既存の HTML を簡単に組み込むためである。
  そのため、上記と同じように動作する HTML は以下のように書くことができる。

<pre>#{code15}

<p>
  行頭のタグは自動的に閉じられるが、"i" タグは閉じられないことに注意する必要がある。
  どちらも特にペナルティは無いため、どちらのアプローチを取っても構わない。
  ただし、この終了タグの機能はインラインタグのみで使い、それ以外のタグで使うべきではない。

<h4>補間

<p>Haskell の変数を HTML に渡すためには、"補間"という機能を使う。

<pre>#{code16}

<p>
  ハッシュ(<code>#</code>) の後ろをブレース(<code>{}</code>)で囲むことで変数補間になる。
  この場合、テンプレートが呼ばれたスコープ内の title 変数が使われる。

<p>
  さらに、補間の中で関数を適用したり、文字列や数値リテラルを使ったり、モジュール修飾したりといったことができる。
  Hamlet は、これらの補間の結果に対して toHtml 関数を適用する。つまり ToHtml インスタンスならどの型でも補間することができる。
  例えば以下のようになる。

<dl>
  <dt>変数補間
  <dd>
    <pre>#{code17}

<p>
  型安全 URL の場合も、アットマーク(<code>@</code>)を使うという部分以外は、ほとんど変数補間と同じである。
  また、キャレット(<code>^</code>)を使うことで、同じ型の他のテンプレートをそこに埋め込むことができる。

<dl>
  <dt>URL 補間と埋め込み補間
  <dd>
    <pre>#{code18}

<h4>属性

<p>
  先程のコードでは、"a" タグの中で href 属性を使っている。
  この構文は HTML とほぼ同じだが、この構文を明確にしていく。

<ul>
  <li>イコールの右側では補間が使える
  <li>HTML と同様、イコールと属性値を省略することができる。そのため、<code>&lt;input type=checkbox checked&gt;</code> というのは、全く問題ない構文である。
  <li>id と class については、便利な記法を用意している。id ならハッシュ、class ならピリオドを使い、<code>&lt;p #paragraphid .class1 .class2&gt;</code> と記述することができる。
  <li>属性値の引用符は省略可能だが、属性値に空白を入れたい場合は引用符が必要になる。
  <li>コロン(<code>:</code>)を使うことで、省略可能な属性を追加することができる。isChecked 変数が True であるときだけチェックボックスに checked 属性を付けたいなら、<code>&lt;input type=checkbox :isChecked:checked&gt;</code> と書く。パラグラフを条件付きで赤にしたいなら、<code>&lt;p :isRed:style="color:red"&gt;</code> と書く。

<h4>条件文

<p>
  ロジックは Haskell の中で書き、Hamlet では可能な限りロジックを組み込まないことが重要だ。
  そのため、Hamlet 内でロジックを制御する文は本当に基本的なものしか用意していない。まずは if, elseif, else である。

<pre>#{code19}

<p>条件文の条件は、すべて通常の補間と同じルールである。

<h4>Maybe

<p>
  同様に Maybe 値を扱う構造もある。
  これは技術的には、if, isJust, fromJust を利用することで達成できる。
  しかしこれを使うことでもっと便利になり、部分関数になってしまうのを回避することができる。

<pre>#{code20}

<p><code>&lt-</code> の左側は単純な識別子でなければならないが、右側は補間と同様に何でも書くことができる。

<h4>Forall

<p>リストに対するループも可能である。

<pre>#{code21}

<h4>With

<p>
  ある文を外へ追い出すためには、with を使う。
  それは基本的に、長い式のシノニムを宣言するときに便利である。

<pre>#{code22}

<h4>Doctype

<p>
  !!! と書くことで、doctype 文を挿入することができる。
  Hamlet はデフォルトでは HTML5 を使うため、doctype は <code>&lt!DOCTYPE html&gt</code> になる。

<pre>#{code23}

<!--
Cassius Syntax

Cassius はオリジナルの CSS テンプレート言語である。
それは単純にブロックを空白で区切る、ブレースとセミコロン不要の言語だ。
それは変数とURLの補間をサポートしているが、組み込みはサポートしていない。
この構文はとても率直だ。

{{{
#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})
}}}


Lucius Syntax

While Cassius uses a modified, whitespace-sensitive syntax for CSS, Lucius is true to the original.
外にある任意の CSS ファイルを、そのまま有効な Lucius ファイルとして取り込むことができる。
ただし Lucius は CSS に対して以下の点が追加されている。

- Cassius のように変数とURL補間を使うことができる。
- CSS ブロックをネストすることができる。
- テンプレート内で変数を宣言することができる。

２番目の点を考慮して書いてみよう。
article タグ内のいくつかのタグに対して特別なスタイルを適用したい場合、プレーンな CSS では以下のように書かなければならなかった。
{{{
article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }
}}}
この場合、多くの節があるわけではないのに article を何度も書かなければならないのが少し面倒だ。
もしこれがダース単位であることを想像して欲しい。
世界で一番最悪というほどではないが、少し苛立たしい。
Lucius はこれを以下のように書くことができる。

{{{
article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}
}}}

Lucius の変数を持つことによって、繰り返しを回避することができる。
単純な例として、共通で使われる色を定義する場合は以下のようにする。

{{{
@textcolor: #ccc; /* just because we hate our users */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }
}}}

あとは、Lucius は CSS と同じである。

Julius Syntax

Julius は、ここで議論した言語の中では一番シンプルだ。
実際、それは言語と言うほどのものではないだろう。
Julius は以前に説明した３つの補間の形式を許可する。そしてそれ以外は何もせず、そのまま出力する。

    もしスカフォードの Yesod サイトで Julius を使ったら、その Javascript が自動的に縮められていることに気がつくだろう。
    これは Julius の機能ではない。代わりに、Yesod が Julius を出力するときに [hjsmin:http://hackage.haskell.org/package/hjsmin]  パッケージを使って縮めている。

Calling Shakespeare

実際に Shakespeare テンプレートをどのように使えばいいのかという疑問が出てくるだろう。
Haskell コードから Shakespeare を呼び出す方法は３つある。

準クォート
    準クォートは Haskell に好きなコンテンツを組み込むことができる。そしてそれはコンパイル時に Haskell コードに変換される。
外部ファイル
    この場合、テンプレートコードは Template Haskell によって参照されるファイルに分けられる。
リロードモード
    上記の両方のモードは何らかの変更があった時に再コンパイルが必要になる。
    リロードモードでは、テンプレートがファイルに分けられ、Template Haskell によって参照されるというのは保持される。しかし、実行時に外部ファイルが書き換えられるたびに再度パースされる。
        リロードモードは Cassius, Lusius, Julius のみ有効で、Hamlet では使えない。
        Hamlet には、Haskell コンパイラによって実行時に再実装可能でない優秀な機能が埋め込まれるためである。

最初の２つのアプローチのどちらかが、実際の製品で使われる。
それらは両方、最終的な実行ファイル内にテンプレートのエンティティが組み込まれる。それは簡単に開発でき、パフォーマンスを増大させる。
準クォートのアドバンテージは、単純であることだ。全て１つのファイル内に収めることができる。
短いテンプレートならこれはよく合う。
しかし一般的に、外部ファイルのアプローチが推奨される。これはなぜかというと、

- 外部ファイルは、伝統的な表現のロジックの分割ができる。
- 外部ファイルとデバッグモードを、単純な CPP マクロで切り替えることができる。つまり、高速に開発しつつ、製品では高いパフォーマンスを発揮することができる。

これらは特別な準クォートと Template Haskell 関数であるため、適切な言語拡張を有効にし、正しい構文を使用することを確認する必要がある。

Quasiquoter
{{{
{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -> HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
<html>
    <head>
        <title>#{title}
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1>#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "My Title" render
}}}
External file
{{{
{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- to control production versus debug
import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render
}}}
{{{
-- @template.lucius
foo { bar: baz }
}}}
¶
関数を表にまとめると、以下のようになる。

| 言語    | 準クォート | 外部ファイル | リロード          |
| Hamlet  | hamlet     | hamletFile   | N/A               |
| Cassius | cassius    | cassiusFile  | cassiusFileReload |
| Lucius  | lucius     | luciusFile   | luciusFileReload  |
| Julius  | julius     | juliusFile   | juliusFileReload  |

Alternate Hamlet Types

これまで、型安全 URL の埋めこまれた Hamlet から HtmlUrl がどのように生成されるかを見てきた。
現在、我々が Hamlet を使って生成することのできる値は３つある。プレーンな HTML, URL と国際化メッセージを含む HTML、ウィジェットの３つである。
最後の１つは widgets チャプターで説明する。

組み込み URL の無いプレーンな HTML を生成するために、我々は "単純化された Hamlet" を使う。
それはいくつかの違いがある。
- 先頭に "s" の付いた、異なる関数セットを使う。そのため、準クォートは shamlet で、外部ファイル関数は shamletFile である。これはどのように発音するかについて、まだ熱い議論が交わされている。
- URL 補間はできない。そうすることによってコンパイルエラーにすることができる。
- 組み込み補間（キャレットによる補間）は、もはや好きな HtmlUrl 値を渡すことができない。このルールは、組み込まれた値がそのテンプレート内で同じ型でなければならない。そのため、この場合は Html でなければならない。 つまり shamlet は、組み込み補間が、通常の変数補間（ハッシュによる補間）に完全に置き換えられる。

¶
国際化（internationalized: i18n）は、通常の Hamlet より少し複雑だ。
これは、型安全URLのコンセプトと実装にとても似ている、メッセージのデータ型のアイデアを基にしている。
サンプルの動機として、我々は、hello と伝え、食べたいリンゴの数を聞くアプリケーションを作りたいとしよう。
我々は、それらのメッセージを表すデータ型を作る。
{{{
data Msg = Hello | Apples Int
}}}
次に、そのデータ型を、人間が読める何かに変換可能にしたいので、以下のレンダリング関数を定義する。
{{{
renderJapanese :: Msg -> Text
renderJapanese Hello = "こんにちは"
renderJapanese (Apples 0) = "あなたはリンゴを買っていない"
renderJapanese (Apples i) = T.concat ["あなたは", T.pack $ show i, "個のリンゴを買った"]
}}}
そして今、我々はテンプレート内で直接、それらの Msg 値を補間したい。
そのためにはアンダースコア補間を使う。
{{{
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
}}}
このテンプレートの種類は、HTML の中にそれらの値を変換するためのいくつかの方法を必要としている。
そのため、型安全URLのように、我々はレンダリング関数を通す。
これを表現するため、我々は新しい型シノニムを定義している。
{{{
type Render url = url -> [(Text, Text)] -> Text
type Translate msg = msg -> Html
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
}}}
重要な点は、あなたはこのテンプレートに renderJapanese, renderEnglish, renderSpanish, renderKligon、あるいはリアルタイムで翻訳する関数（その質はもちろん関数に依存する）を通すことができることである。
完全なサンプルプログラムは以下のようになる。

i18n Example
{{{
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze (toHtml)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -> [(Text, Text)] -> Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderJapanese :: Msg -> Text
renderJapanese Hello = "こんにちは"
renderJapanese (Apples 0) = "あなたはリンゴを買っていない"
renderJapanese (Apples i) = T.concat ["あなたは", T.pack $ show i, "個のリンゴを買った"]

template :: Int -> HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderJapanese) renderUrl
}}}

Other Shakespeare

HTML, CSS, JavaScript のヘルパーに加えて、Shakespeare を有効にする、いくつかのより汎用的なものがある。
shakespeare-text は、Ruby や Python のような慣れたスクリプト言語のように、補間された文字列を生成するための単純な方法を提供する。
このパッケージのユーティリティは当然、Yesod 以外でも使うことができる。
{{{
{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "apples" 5
    , Item "bananas" 10
    ]

main :: IO ()
main = forM_ items $ \item -> TLIO.putStrLn
    [lt|You have #{show $ itemQty item} #{itemName item}.|]
}}}
この単純なサンプルの要点は以下の通りである。
- ３つの異なる、関連したテキストデータ型（String, strict Text, lazy Text）を使っていることに注意。それらは混ぜて使うことができる。
- 準クォートに lt を使うことで、lazy Text を生成する。strict Text を生成する st もある。

General Recommendations

これは、Yesod コミュニティから得られた、Shakespeare を最大限に活かす方法についての一般的なヒントだ。
（もしもっといい方法があるなら、このパラグラフにコメントして欲しい）

- 実際のサイトでは、外部ファイルを使う。ライブラリでは、長すぎないものであれば、準クォートを使っても構わない。
- Patrick Brisbin は、コーディングを楽にする [Vim code highlighter:https://github.com/pbrisbin/html-template-syntax] を使っている。
- あなたはほとんど常に、それぞれの行の最初を Hamlet タグで始め、そのタグの後ろに開始/終了タグを組み込まないでおくべきだ。この例外は、大きなテキストブロック内にある <i> と <b> タグだけだ。
-->
