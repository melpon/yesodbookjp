<h1>ウィジェット

<p>
  Web 開発で難しいことの１つは、クライアント側で HTML, CSS, JavaScript を使い分けなければならないということだ。
  これらは同一ページ上の異なる場所に配置する必要がある。CSS なら head の style タグの中に、JavaScript なら head の script タグの中に、そしてコンテンツは body の中に。
  実際のところ、これは構造（HTML）、スタイル（CSS）、ロジック（JavaScript）を分離することができるため、１つのページを構築するだけなら、非常にうまく分けられる。
  しかしこれは、複数のページで同じコード片を使いたいと思ったときに、頭を悩ませることになる。
  ウィジェットは、この問題に対する Yesod の解決策だ。

<p>
  ４つのテンプレート言語、Hamlet, Cassius, Lucius, Julius は、単に出力を生成するだけのツールだ。ウィジェットは、それらをシームレスに動作させるための接着剤として機能する。

<h2>概要

<pre>#{code1}

<p>これは以下のような HTML を生成する（インデント済み）。

<pre>#{code2}

<h2>ウィジェットとは

<p>
  表面的なレベルで言えば、HTML ドキュメントは単にネストされたタグの集まりでしかない。
  このタグの構造を直接埋め込んで生成するというのは、多くの HTML 生成ツールが取る方法だ。
  例えばナビゲーションバーのコンポーネントを作る場合を考えてみよう。
  これは、適当に関数を呼び出すだけでナビゲーションバーが挿入されて欲しいと思うだろう。つまり、コンポーネントは "プラグアンドプレイ" であって欲しいのだ。

<p>
  しかしこれは、単にタグを埋め込むだけでは難しい。
  ナビゲーションバーはおそらく、１つの HTML と、いくつかの CSS と JavaScript で構成されている。
  そのため、最低でも３つのセットが正しく HTML に埋め込まれているかを確認しなければならない。

<p>
  ウィジェットはこれとは異なる方法を用いる。
  ウィジェットは、１つのページをコンポーネントの集まりとして見る。
  例を挙げると、以下のようなものである。

<ul>
  <li>タイトル
  <li>外部スタイルシート
  <li>外部スクリプト
  <li>CSS 宣言
  <li>JavaScript コード
  <li>任意の &lt;head&gt; のコンテンツ
  <li>任意の &lt;body&gt; のコンテンツ
  <li>及び、これらの組み合わせ

<p>
  これらの組み合わせをコンポーネントとして用意した場合、問題になるのは、同じ内容の重複だ。
  例えばタイトルは１度しか設定してはならないし、外部スクリプトやスタイルシートは、同じURLなら再度挿入する必要は無い。
  ウィジェットの役割は、これらを適切に組み合わせられるようにすることである。
  つまり、１回目以降のタイトルの設定を無視したり、外部スクリプトやスタイルシートから重複を除けたり、head や body のコンテンツを繋ぎ合わせるといった作業を行なう。

<h2>ウィジェットの構築

<p>
  ウィジェットを作る方法はいくつかある。最も一般的な方法は、ToWidget 型クラスと、そのメソッドである toWidget を使うことだ。
  これは Shakespeare テンプレートを直接ウィジェットに変換する。
  つまり Hamlet コードは body に、Julius スクリプトは head の script の中に、Cassius と Lucius は head の style タグの中に埋め込まれることになる。

<blockquote>
  実際には、デフォルトの動作をオーバーライドし、スクリプトやスタイルのコードを別々のファイルに出力するとができる。
  スカフォードサイトはこれを自動的に提供する。
  非同期なスクリプトのロードによる書き換えについては{{Yesod型クラスの章}}で説明する。
  これは非同期にスクリプトのロードを行い、body の末尾にスクリプトを配置する。

<p>
  ただ、head に入れるべきか body に入れるべきか、自動的に判断できない場合がある。
  例えば &lt;meta&gt; タグは head と body のどちらに現れても構わない。
  あるいは JavaScript は、head ではなく body に現れても構わない。
  こういった問題のために、Yesod は更に ToWidgetHead と ToWidgetBody の２つの型クラスを提供している。
  これらは名前通りの動作を行なう。

<blockquote>
  Lucius と Cassius は、ToWidgetBody がインスタンス化されていない。これは body 内に style タグを置くことができないからである。

<p>
  また、特定の種類のウィジェットを作るための関数が多数存在する。

<dl>
  <dt>setTitle
  <dd>title タグの HTML を書き換える
<dl>
  <dt>addCassiusMedia
  <dt>addLuciusMedia
  <dd>
    toWidget と同じように動作するが、メディアの種類を追加で引数に取る。これは印刷用のスタイルシートを作る場合などに利用することができる。（印刷用のスタイルシートを作るためには
    <code>&lt;link rel="stylesheet" href="print.css" type="text/css" media="print" /&gt;
    などのように media を指定する必要がある。）
<dl>
  <dt>addStylesheet
  <dd>&lt;link&gt; タグを使って外部スタイルシートを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addStylesheetRemote
  <dd>addStylesheet と同じだが、通常の URL を取る。Google の jQuery UI の CSS のような、CDN でホストされているファイルを参照する場合などで利用する。
<dl>
  <dt>addScript
  <dd>&lt;script&gt; タグを使って外部スクリプトを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addScriptRemote
  <dd>addScript と同じだが、通常の URL を取る。Google の jQuery のような、CDN でホストされているファイルを参照する場合などで利用する。

<h2>ウィジェットの組み合わせ

<p>
  ウィジェットの目的は、結合可能性（composability）を高めることだ。
  ウィジェットは、小さな HTML, CSS, JavaScript のピースを組み合わせ、複雑なものを作ることができる。そしてその複雑なものを組み合わせ、ページを作っていく。
  これは Widget モナドのインスタンスを使うことで自然に記述することができる。
  つまりそれぞれのピースを do 記法で記述することができる。

<dl>
  <dt>ウィジェットの組み合わせ
  <dd>
    <pre>#{code3}

<blockquote>
  これは Monoid インスタンスとして使うこともできる。つまり mconcat や Writer モナドを使って記述することもできる。
  ただ、do 記法が一番自然だと感じるだろう。

<h2>IDの生成

<p>
  本当に再利用できるコードにしたい場合、名前の衝突についても考慮する必要がある。
  例えばウィジェットになっている２つのライブラリがあるとする。これらのライブラリのスタイルが、両方とも "foo" というクラス名を使っていた場合、名前が衝突してしまう。
  これをできる限り回避するために、newIdent 関数がある。
  この関数は、あるハンドラ内でユニークな文字列を自動的に生成する。

<dl>
  <dt>newIdentの利用
  <dd>
    <pre>#{code4}

<blockquote>
  ここで使っている lift というのは何だろうか。
  これは、Handler レイヤから Widget レイヤに変換するための関数である。
  Widget は Handler の上に座すモナド変換子であるため、lift 関数によって変換することができる。
  lift を使って Widget モナド変換子に変換することで、様々なアクションを行なうことができるようになる。
  例えばウィジェット内でデータベースへのクエリを投げたりすることができるようになる。
  詳細は{{Yesodのモナド}}で説明する。

<!--
whamlet

あなたはフッターを表すための他のHamletテンプレートを組み込む、適切で標準的なHamletテンプレートを手に入れたとする。
{{{
page = [hamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]

footer = [hamlet|
<footer>
    <p>That's all folks!
|]
}}}
これは正しく動く。ただしフッターが plain old HTML なら。
もし我々が何らかのスタイルを追加したい場合はどうすればいいだろうか。
我々はfooterのウィジェットを書き換えることで、簡単にフッターに華を添えることができる。
{{{
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]
}}}
しかしこれは動かない。Hamlet テンプレートは他のHamletテンプレートしか埋めこむことができない。つまりウィジェットを組み込むことはできない。
これは whamlet の出番だ。これは通常のHamletと同じように変数(#{...})やURL(@{...})補完が使える。しかし組み込み(^{...})は通常のHamletではなくWidgetを取る。そして最終的な結果はWidgetになる。これを使うには、以下のようにするだけだ。
{{{
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
}}}
テンプレートをファイルに分けるために whamletFile もある。

    スカフォードサイトはもっと便利な関数である widgetFile を使っている。widgetFile は Lucius, Cassius, Julius ファイルも自動的にインクルードする。この話は [scaffolding chapter] でカバーする。
    The scaffolded site has an even more convenient function, widgetFile, which will also include your Lucius, Cassius, and Julius files automatically. We'll cover that in the scaffolding chapter.

Types

あなたは、私が型シグネチャを回避していたことに気がついたかもしれない。 
これはなぜかというと、少し複雑になってしまうからだ。ほとんどの基本的なレベルでは、いつも使っているWidgetという型シノニムがあることを知っておく必要がある。
技術的な詳細は以下に記述しているが、よく分からなくても心配しなくていい。  
 
実は、Widgetという型はYesodに定義されていない。その正確な意味はサイト間で変わるからだ。代わりに、もっと一般的な型である GWidget sub  master a  がある。最初の二つのパラメータは、それぞれサブとマスターの基礎的な型を与える。最後のパラメータは、Monadが持つような、格納されている値である。
 
サブ/マスターの処理するものは何だろうか。あなたがCRUDのような再利用可能なコードを書くとき、 任意の他のYesodアプリケーションに組み込まれるサブサイトとしてそれを書くことができる。 そのような場合、サブとマスターサイトの両方の情報を保持する必要がある。最もシンプルな例は、型安全URLだ。YesodはCRUDサブサイトのためのルートをどのように取るのか、適切にレンダリングするためにマスターサイトのためのルートの中をどのように変えるのか知る必要がある。
 
しかしながら、サブ/マスターサイトの違いは、あなたがサブサイトと対話しているときのみ重要だ。あなたがあなたの標準的なレスポンスコードを書いているとき、あなたはアプリケーションを処理しているので、サブとマスターサイトは同じだ。これが最も普通のケースになって以来、スカフォードサイトは便利な型シノニムを宣言するようになった。あなたの基本的な型がMyCoolAppだとすれば、type Widget = GWidget MyCoolApp MyCoolApp () と定義される。

{{{
footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]

page :: Widget
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
}}}

もしあなたが注意を払っていたなら、混乱していたかもしれない。
我々は Widget の前に lift を使ったが、GWidget は実際にはモナド変換子ではない。
ここで何が起きているのか。古いバージョンのYesodでは、それは Handler 型周りの変換子だった。
不運なことに、これはエラーメッセージのパースを難しくした。
結果として、GWidget は現在、そのモナド変換子のエッセンスを隠した newtype ラッパーである。
しかし我々はまだ、内部の Handler モナドから lift できるようにしたいと考えている。

これを解決するために、Yesodは別の方法を提供している。
標準の MonadTrans インスタンスと、GWidget のような特殊な newtype ラッパーの両方とも動作する、もっと一般的な lift 関数を提供した。
結果として、GWidget はナイスなエラーメッセージをキープしたまま、標準の変換子のように扱えるようになった。

最後にもう１つだけ。WidgetとGWidgetの関係のように、HandlerとGHandlerも同じような関係である

Using Widgets

Widget データ型はうまい具合に作られているが、ユーザがそれをうまく扱うにはどうすればいいだろうか。
最も普通の関数は defaultLayout だ。これは基本的に、Widget -> Handler RepHtml の型シグネチャを持つ ("基本的に"と付けたのは GHandler の話になるからだ)。RepHtml は、ワイヤーを超えて送る準備ができているいくつかの生の HTML 出力を含むデータ型だ。

defaultLayout は実際には型クラスメソッドだ。これはそれぞれのアプリケーションでオーバーライドできる。
これが Yesod アプリをテーマする方法だ。
なので、我々はまだ疑問を持ち続けている。我々が defaultLayout の内部を見る時、どのように Widget を unwrap すればいいのか。
答えは、widgetToPageContent だ。いくつかの(簡単な)型を見てみよう。

{{{
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
}}}

これは我々が欲しい物に近づいている。
我々は今、head と body, title を作る HTML に直接アクセスしている。
このポイントは、我々は、サイトレイアウトに沿った、単一のドキュメントの中で Hamlet を混ぜ合わせて使うことができ、そしてユーザが見ることのできる Hamlet が返す実際の HTML をレンダリングするための hamletToRepHtml を使う。次の形はこのプロセスのデモだ。

Using widgetToPageContent
{{{
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout
}}}

    我々が Widget, Handler と書く代わりに GWidget, GHandler と書いたことに気がついただろうか。なぜなら、defaultLayout はマスターサイトと同じようにスタイリングすることを保証するサブサイトから呼ばれるメソッドだからである。
    したがって、ここでは型をフレキシブルにしておく必要がある。

これで全てうまくいくように思えるが、１つだけ問題がある。style タグだ。
これはいくつかの問題を持っている。

 - Lucius や Cassius と違い、それはコンパイル時に正確にチェックされない。
 - 確かに現在のサンプルはとてもシンプルだが、もっと複雑な場合では、文字エスケープの問題を起こす。
 - 我々は今、この方法の代わりに２つの style タグを持つ。１つは myLayout で提供した。もう１つは widget のスタイルセット上の pageHead で生成した。

我々は、この問題に対処するための１つ以上のトリックを持っている。
我々は widgetToPageContent を呼び出す前に、widget 自身へいくつかの最後の調整を呼び出す。
それは実際にはとても簡単なことだ。do 記法をもう一度使う。

Last-Minute Widget Adjustment
{{{
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]
}}}

Summary

各ページの基本的なビルディングブロックはウィジェットだ。
HTML, CSS, JavaScript の個々のスニペットは多相的な toWidget 関数によってウィジェットに変換できる。
do記法を使うことで、個々のウィジェットを組み合わせて徐々に大きなウィジェットにしていき、最終的にページの全てのコンテンツを含むようになる。

ウィジェットの unwrap は通常、defaultLayout 関数で行なう。
すべてのページを直感的に統一するために使うことができる。
-->
