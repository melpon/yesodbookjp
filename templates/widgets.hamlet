<h1>ウィジェット

<p>
  Web 開発で難しいことの１つは、クライアント側で HTML, CSS, JavaScript を使い分けなければならないということだ。
  これらは同一ページ上の異なる場所に配置する必要がある。CSS なら head の style タグの中に、JavaScript なら head の script タグの中に、そしてコンテンツは body の中に。
  実際のところ、これは構造（HTML）、スタイル（CSS）、ロジック（JavaScript）を分離することができるため、１つのページを構築するだけなら、非常にうまく分けられる。
  しかしこれは、複数のページで同じコード片を使いたいと思ったときに、頭を悩ませることになる。
  ウィジェットは、この問題に対する Yesod の解決策だ。

<p>
  ４つのテンプレート言語、Hamlet, Cassius, Lucius, Julius は、単に出力を生成するだけのツールだ。ウィジェットは、それらをシームレスに動作させるための接着剤として機能する。

<h2>概要

<pre>#{code1}

<p>これは以下のような HTML を生成する（インデント済み）。

<pre>#{code2}

<h2>ウィジェットとは

<p>
  表面的なレベルで言えば、HTML ドキュメントは単にネストされたタグの集まりでしかない。
  このタグの構造を直接埋め込んで生成するというのは、多くの HTML 生成ツールが取る方法だ。
  例えばナビゲーションバーのコンポーネントを作る場合を考えてみよう。
  これは、適当に関数を呼び出すだけでナビゲーションバーが挿入されて欲しいと思うだろう。つまり、コンポーネントは "プラグアンドプレイ" であって欲しいのだ。

<p>
  しかしこれは、単にタグを埋め込むだけでは難しい。
  ナビゲーションバーはおそらく、１つの HTML と、いくつかの CSS と JavaScript で構成されている。
  そのため、最低でも３つのセットが正しく HTML に埋め込まれているかを確認しなければならない。

<p>
  ウィジェットはこれとは異なる方法を用いる。
  ウィジェットは、１つのページをコンポーネントの集まりとして見る。
  例を挙げると、以下のようなものである。

<ul>
  <li>タイトル
  <li>外部スタイルシート
  <li>外部スクリプト
  <li>CSS 宣言
  <li>JavaScript コード
  <li>任意の &lt;head&gt; のコンテンツ
  <li>任意の &lt;body&gt; のコンテンツ
  <li>及び、これらの組み合わせ

<p>
  これらの組み合わせをコンポーネントとして用意した場合、問題になるのは、同じ内容の重複だ。
  例えばタイトルは１度しか設定してはならないし、外部スクリプトやスタイルシートは、同じURLなら再度挿入する必要は無い。
  ウィジェットの役割は、これらを適切に組み合わせられるようにすることである。
  つまり、１回目以降のタイトルの設定を無視したり、外部スクリプトやスタイルシートから重複を除けたり、head や body のコンテンツを繋ぎ合わせるといった作業を行なう。

<h2>ウィジェットの構築

<p>
  ウィジェットを作る方法はいくつかある。最も一般的な方法は、ToWidget 型クラスと、そのメソッドである toWidget を使うことだ。
  これは Shakespeare テンプレートを直接ウィジェットに変換する。
  つまり Hamlet コードは body に、Julius スクリプトは head の script の中に、Cassius と Lucius は head の style タグの中に埋め込まれることになる。

<aside>
  実際には、デフォルトの動作をオーバーライドし、スクリプトやスタイルのコードを別々のファイルに出力するとができる。
  スカフォードサイトはこれを自動的に提供する。
  非同期なスクリプトのロードによる書き換えについては{{Yesod型クラスの章}}で説明する。
  これは非同期にスクリプトのロードを行い、body の末尾にスクリプトを配置する。

<p>
  ただ、head に入れるべきか body に入れるべきか、自動的に判断できない場合がある。
  例えば &lt;meta&gt; タグは head と body のどちらに現れても構わない。
  あるいは JavaScript は、head ではなく body に現れても構わない。
  こういった問題のために、Yesod は更に ToWidgetHead と ToWidgetBody の２つの型クラスを提供している。
  これらは名前通りの動作を行なう。

<aside>
  Lucius と Cassius は、ToWidgetBody がインスタンス化されていない。これは body 内に style タグを置くことができないからである。

<p>
  また、特定の種類のウィジェットを作るための関数が多数存在する。

<dl>
  <dt>setTitle
  <dd>title タグの HTML を書き換える
<dl>
  <dt>addCassiusMedia
  <dt>addLuciusMedia
  <dd>
    toWidget と同じように動作するが、メディアの種類を追加で引数に取る。これは印刷用のスタイルシートを作る場合などに利用することができる。（印刷用のスタイルシートを作るためには
    <code>&lt;link rel="stylesheet" href="print.css" type="text/css" media="print" /&gt;
    などのように media を指定する必要がある。）
<dl>
  <dt>addStylesheet
  <dd>&lt;link&gt; タグを使って外部スタイルシートを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addStylesheetRemote
  <dd>addStylesheet と同じだが、通常の URL を取る。Google の jQuery UI の CSS のような、CDN でホストされているファイルを参照する場合などで利用する。
<dl>
  <dt>addScript
  <dd>&lt;script&gt; タグを使って外部スクリプトを読み込む。これは型安全 URL で指定する。
<dl>
  <dt>addScriptRemote
  <dd>addScript と同じだが、通常の URL を取る。Google の jQuery のような、CDN でホストされているファイルを参照する場合などで利用する。

<h2>ウィジェットの組み合わせ

<p>
  ウィジェットの目的は、結合可能性（composability）を高めることだ。
  ウィジェットは、小さな HTML, CSS, JavaScript のピースを組み合わせ、複雑なものを作ることができる。そしてその複雑なものを組み合わせ、ページを作っていく。
  これは Widget モナドのインスタンスを使うことで自然に記述することができる。
  つまりそれぞれのピースを do 記法で記述することができる。

<dl>
  <dt>ウィジェットの組み合わせ
  <dd>
    <pre>#{code3}

<aside>
  これは Monoid インスタンスとして使うこともできる。つまり mconcat や Writer モナドを使って記述することもできる。
  ただ、do 記法が一番自然だと感じるだろう。

<h2>IDの生成

<p>
  本当に再利用できるコードにしたい場合、名前の衝突についても考慮する必要がある。
  例えばウィジェットになっている２つのライブラリがあるとする。これらのライブラリのスタイルが、両方とも "foo" というクラス名を使っていた場合、名前が衝突してしまう。
  これをできる限り回避するために、newIdent 関数がある。
  この関数は、あるハンドラ内でユニークな文字列を自動的に生成する。

<dl>
  <dt>newIdentの利用
  <dd>
    <pre>#{code4}

<aside>
  ここで使っている lift というのは何だろうか。
  これは、Handler レイヤから Widget レイヤに変換するための関数である。
  Widget は Handler の上に座すモナド変換子であるため、lift 関数によって変換することができる。
  lift を使って Widget モナド変換子に変換することで、様々なアクションを行なうことができるようになる。
  例えばウィジェット内でデータベースへのクエリを投げたりすることができるようになる。
  詳細は{{Yesodのモナド}}で説明する。

<h2>whamlet

<p>
  Hamlet でフッターを組み込みたい場合、以下のように書くことができる。

<pre>#{code5}

<p>
  これは正しく動作する。
  しかし、もしこのフッターに何らかのスタイルを加えたいと思った場合はどうすればいいだろうか。
  単純には、Hamletテンプレートではなくfooterをウィジェットにすることで解決できそうに感じる。

<pre>#{code6}

<p>
  しかしこれは動作しない。Hamlet テンプレートの組み込み補間は、Hamlet テンプレートしか組み込めない。つまりウィジェットを組み込むことができない。
  この場合、whamlet を利用する。これは通常のHamletと同じように変数補間（<code>&#35;{...}</code>）や URL 補間（<code>&#64;{...}</code>）を利用することができる。
  ただし組み込み補間（<code>&#94;{...}</code>）は、HamletではなくWidgetを取るようになる。そして最終的な結果はWidgetになる。
  これは以下のように利用する。

<pre>#{code7}

<p>
  hamletFile に対する、whamletFile 関数もある。

<aside>
  スカフォードサイトでは、widgetFile という、もっと便利な関数を使っている。
  これは Lucius, Cassius, Julius ファイルも自動的にインクルードする。
  詳細については {{スカフォードの章}} で説明する。

<h3>型

<p>
  先ほどの例は、わざと型シグネチャを書かなかった。これは少し複雑な話になってしまうからだ。
  技術的な詳細を以下に記述しているが、理解できなくても問題は無い。
  大抵は、Widgetという型シノニムを使えば解決するということだけを覚えておけばいい。

<p>
  実のところ、Widgetという型はYesodには定義されていない。
  その正確な意味がサイト毎に変わるからだ。
  代わりに、<code>GWidget sub master a</code> という、一般化された型が定義されている。
  Yesod のベースの型が <code>MyCoolApp</code> だとすれば、<code>type Widget = GWidget MyCoolApp MyCoolApp ()</code> という型が、スカフォードサイトによって自動的に定義される。

<p>
  sub/master というのは何をするためのものだろうか。
  これは、CRUDのような再利用可能なコードを書き、他のYesodアプリケーションに組み込まれる際に重要になる。この場合、サブサイトとマスターサイトの両方の情報を保持しておく必要がある。
  例えば一番簡単な例として、型安全 URL がある。
  Yesod のマスターサイトは、適切にURLレンダリングを行なうために、CRUDサブサイトがどんなルートを取るのか、マスターサイトのルートをどのように変更すればいいのかを知っている必要がある。

<p>
  ただし、サブサイト/マスターサイトの違いは、サブサイトを作っているときだけ重要になる。
  通常の処理を書いているときは、サブサイトとマスターサイトは同じものになる。
  これが一般的であるため、スカフォードは上記のような Widget 型を用意しているのだ。
  先程の例に型をつけるなら、最初に書いたとおり、以下のようにするだけでいい。

<pre>#{code8}

<aside>
  <p>
    newIdent を説明している箇所で、Widget はモナド変換子であると言っていたが、実のところ、そうではない。
    古いバージョンのYesodでは、実際にモナド変換子だった。
    しかしこれは、エラーメッセージが読めないものになってしまった。
    そのため、GWidget は現在、モナド変換子のエッセンスを隠した、newtype のラッパーである。
  <p>
    このままだと lift 関数が使えないため、Yesod は MonadTrans インスタンスと、GWidget のような特殊な newtype ラッパーの両方で動作する、もっと一般化した lift 関数を定義した。
    これによって、GWidget は分かりやすいエラーメッセージを表示しつつ、lift 関数を使えるようになったのである。

<p>
  Widget, GWidget の関係と同様、Handler, GHandler も同じような関係である。

<h2>ウィジェットの利用

<!--
Using Widgets

Widget データ型はうまい具合に作られているが、ユーザがそれをうまく扱うにはどうすればいいだろうか。
最も普通の関数は defaultLayout だ。これは基本的に、Widget -> Handler RepHtml の型シグネチャを持つ ("基本的に"と付けたのは GHandler の話になるからだ)。RepHtml は、ワイヤーを超えて送る準備ができているいくつかの生の HTML 出力を含むデータ型だ。

defaultLayout は実際には型クラスメソッドだ。これはそれぞれのアプリケーションでオーバーライドできる。
これが Yesod アプリをテーマする方法だ。
なので、我々はまだ疑問を持ち続けている。我々が defaultLayout の内部を見る時、どのように Widget を unwrap すればいいのか。
答えは、widgetToPageContent だ。いくつかの(簡単な)型を見てみよう。

{{{
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
}}}

これは我々が欲しい物に近づいている。
我々は今、head と body, title を作る HTML に直接アクセスしている。
このポイントは、我々は、サイトレイアウトに沿った、単一のドキュメントの中で Hamlet を混ぜ合わせて使うことができ、そしてユーザが見ることのできる Hamlet が返す実際の HTML をレンダリングするための hamletToRepHtml を使う。次の形はこのプロセスのデモだ。

Using widgetToPageContent
{{{
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout
}}}

    我々が Widget, Handler と書く代わりに GWidget, GHandler と書いたことに気がついただろうか。なぜなら、defaultLayout はマスターサイトと同じようにスタイリングすることを保証するサブサイトから呼ばれるメソッドだからである。
    したがって、ここでは型をフレキシブルにしておく必要がある。

これで全てうまくいくように思えるが、１つだけ問題がある。style タグだ。
これはいくつかの問題を持っている。

 - Lucius や Cassius と違い、それはコンパイル時に正確にチェックされない。
 - 確かに現在のサンプルはとてもシンプルだが、もっと複雑な場合では、文字エスケープの問題を起こす。
 - 我々は今、この方法の代わりに２つの style タグを持つ。１つは myLayout で提供した。もう１つは widget のスタイルセット上の pageHead で生成した。

我々は、この問題に対処するための１つ以上のトリックを持っている。
我々は widgetToPageContent を呼び出す前に、widget 自身へいくつかの最後の調整を呼び出す。
それは実際にはとても簡単なことだ。do 記法をもう一度使う。

Last-Minute Widget Adjustment
{{{
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]
}}}

Summary

各ページの基本的なビルディングブロックはウィジェットだ。
HTML, CSS, JavaScript の個々のスニペットは多相的な toWidget 関数によってウィジェットに変換できる。
do記法を使うことで、個々のウィジェットを組み合わせて徐々に大きなウィジェットにしていき、最終的にページの全てのコンテンツを含むようになる。

ウィジェットの unwrap は通常、defaultLayout 関数で行なう。
すべてのページを直感的に統一するために使うことができる。
-->
