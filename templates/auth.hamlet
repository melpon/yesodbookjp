<h1>認証と認可

<p>
  認証（Authentication）と認可（Authorization）はよく似ているが、それらは全く別の概念だ。
  前者はユーザを識別する処理で、後者はユーザによってアクセス権が設定されているかを確認する処理だ。
  両者は単に認証（auth）と呼ばれることがあるため、これらの概念は混同されがちだ。

<p>
  Yesod はデフォルトで、OpenID, BrowserID, OAuth といったサードパーティによる認証をサポートしている。
  これらはユーザの信用情報（credential）を検証する外部のシステムである。Yesod アプリケーションは、この外部のシステムによる検証結果を信用して認証を行なう。
  さらに Yesod は、ユーザ名/パスワードの組み合わせや、メール/パスワードといった組み合わせによる認証もサポートしている。
  前者の方法は、ユーザにとっても、実装者にとっても簡単な保証しか行なわない。つまり、パスワードヒントは無いし、十分なセキュリティが担保されているわけでもない。
  後者の方法は、開発者がもっと細かく制御できるようになっている。

<p>
  認可においては、Yesod にはアドバンテージがある。
  Yesod には REST と型安全 URL があるため、シンプルかつ宣言的に作ることができる。
  さらに、認可のコードはすべて Haskell で書かれているため、言語の柔軟性を生かして、やりたいことを簡単に実現することができる。

<p>
  この章では、Yesod で認証と認可の書き方と、認証オプションの違いによるトレードオフについて議論する。

<h2>概要

<p>
  <a href="http://hackage.haskell.org/package/yesod-auth">yesod-auth
  \ パッケージは、様々な認証プラグインについて、統合されたインターフェースを提供している。
  これを使うために必要なバックエンドは、ユーザを一意に識別することができる文字列だけである。
  例えば OpenID では実際の OpenID である。BrowserID ではメールアドレスである。
  HashDB （パスワードをハッシュ化してデータベースに格納するプラグイン）ではユーザ名である。

<p>
  それぞれの認証プラグインは、それ自身がログイン機能を提供している。
  例えば外部サイトのパッシングトークン経由での認証や、メール/パスワードフォーム経由での認証などである。
  ログインが成功した後、認証プラグインはセッションに<code>AuthId</code>の値をセットする。
  この<code>AuthId</code>は通常、Persistent ID である。これはユーザをトラッキングし続けるために使われる。

<p>
  あるユーザの<code>AuthId</code>を取得する関数はいくつかある。
  最も一般的なのは、<code>maybeAuthId</code>, <code>requireAuthId</code>, <code>maybeAuth</code>, <code>requireAuth</code> である。
  require〜 系の関数は、ユーザがログインしていない場合にはログインページへとリダイレクトする。
  また、後ろ２つの 〜Auth 系の関数は、ID だけでなく、エンティティも取得する。

<p>
  セッションは、<code>AuthId</code> のセッション情報をストレージに格納するところから全てが始まる。
  セッション情報は HMAC で暗号化し、クライアントのクッキーに保存する。
  このとき、クライアントのクッキーは設定された時間が過ぎると自動的にタイムアウトするようになっている。
  また、セッション情報はサーバーサイドで保持していないため、ログアウトするには単にクッキーからセッション情報を削除するだけでいい。
  つまり、もしユーザが古いクッキーの値を再利用しているなら、セッションはまだ有効であるということだ。

<p>
  一方で、認可は <code>Yesod</code> 型クラスのいくつかのメソッドを使って操作する。
  これらのメソッドは、全てのリクエストについて、アクセスを許可する/しない、あるいはユーザ認証が必要かどうかを決める。
  デフォルトでは、全てのリクエストについてアクセスを許可するようになっている。
  また、型クラスのメソッドを使わなくても、個々の関数で <code>requireAuth</code> 系を呼び出してアドホックに認可を実装するという方法もある。
  しかしこれは、宣言的な認可システムのメリットを台無しにしてしまう。

<h2>認証する

<p>では認証のサンプルを見てみよう。

<pre>#{code1}

<p>
  まずはルートの宣言から見ていこう。
  最初の行では標準的なトップページを宣言している。
  次の行では、認証のためのサブサイトを宣言している。
  以前に説明したように、サブサイトの宣言では、サブサイトのパス、ルート名、サブサイト名、サブサイトを取得する関数を渡す必要がある。
  つまり、

<pre>/auth AuthR Auth getAuth

<p>
  この行は <code>getAuth :: MyAuthSite -> Auth</code> であるような関数が必要だということが分かる。
  この <code>getAuth</code> 関数はあらかじめ #
  <a href="http://hackage.haskell.org/package/yesod-auth">yesod-auth
  \ が提供しているため、自分で書く必要は無い。
  通常、サブサイトの動作を設定するには、そのサブサイト用のオブジェクトを作り、サブサイトを取得する関数で、そのオブジェクトを返す必要がある。
  しかし今回の場合、サブサイトのオブジェクトを作る必要は無く、<code>YesodAuth</code> という型クラスのインスタンスを作るだけで構わない。

<p>
  なぜサブサイトのオブジェクトを作るようにしなかったのか。
  それは、このサブサイトに与えたい設定は様々であり、レコード型でそれを記述するのが手間だったからである。
  また、<code>AuthId</code> という関連型を保持したいというのもある。これを実現するために型クラスを使うというのは、最も自然な解決策である。

<p>
  しかしそれなら、なぜ全てのサブサイトで型クラスを使うようにしなかったのだろうか。
  これは、型クラスの場合、１つのサイトに１つのインスタンスしか作れないからだ。
  この場合、２つ以上のルートから静的ファイルを転送するといったことができなくなってしまう。
  また、型クラスではなくオブジェクトを使えば、アプリケーションの初期化時にデータをロードするといった処理が簡単に書ける。
  そのため、オブジェクトを使う方が一般的である。

<p>YesodAuth インスタンスは、６つの宣言を要求している。
<ul>
  <li>
    <code>AuthId
    は関連型である。これは、<code>maybeAuthId</code> や <code>requireAuthId</code> などでユーザがログインしたかどうかを問い合わせるときに使われる値である。
    ここでは単純に <code>Text</code> を <code>AuthId</code> にしている。
    email などでユーザを識別するようなケースは、この後で見ていく。
  <li>
    <code>getAuthId</code>
    は、<code>Creds</code>(credentials: 信用情報)から <code>AuthId</code> を返す関数だ。
    この <code>Creds</code> 型は、３つの情報を保持する。
    １番目はバックエンドで使われる認証プラグイン（今回の場合は BrowserID と GoogleEmail）、
    ２番目は識別子、
    ３番目はそれぞれのバックエンド固有の情報である。
    今回の場合、２番目の情報を取り出す<code>credsIdent</code>関数を使って<code>AuthId</code>（今回の場合は<code>Text</code>）を返している。
  <li>
    <code>loginDest
    には、ログインに成功した後に遷移するリダイレクト先のルートを指定する。
  <li>
    同様に、
    <code>logoutDest
    には、ログアウトした後に遷移するリダイレクト先のルートを指定する。
  <li>
    <code>authPlugins
    は、使用する認証用のバックエンドのリストを指定する。
    今回のサンプルでは、Mozzila の BrowserID システムを使った BrowserID バックエンドと、Google アカウントのメールアドレス使った Google Email バックエンドを指定している。
    これらのバックエンドは非常に使い勝手が良い。なぜなら、
    <li>
      これらはセットアップを必要としない。
      それに対して Facebook や OAuth バックエンドなどの場合は、信用情報のセットアップを行なう必要がある。
    <li>
      これらはユーザの識別子としてメールアドレスを使っている。
      メールアドレスは、多くのユーザが手軽に利用できる識別子である。
      それに対して OpenID バックエンドなどの場合は、ユーザの識別子として URL を使うことになる。
  <li>
    <code>authHttpManager
    は、HTTP 接続のマネージャを返す。
    多くの認証バックエンドは何度も HTTP 接続を行なうが、その際の接続を共有することで、接続に掛かるコストを回避するために使われる。
    つまり HTTP 接続を行なわないバックエンドを利用する場合は必要ない。
    その場合は単に<code>authHttpManager = error "authHttpManager"</code>などと記述すれば良い。

<p>
  今回の<code>RootR</code>ハンドラは、ログイン/ログアウトページへの単純なリンクを表示する。
  どちらのリンクが表示されるかは、現在ログインしているかどうかによって変わる。
  サブサイトのリンクの構築方法にも注目して欲しい。
  最初にサブサイトのルート（<code>AuthR</code>）を指定し、それに続いてサブサイトの各ページ（<code>LoginR</code>や<code>LogoutR</code>）を指定する。
<p>
  このページは、ユーザ視点で見ると、以下の様なログインプロセスになる。

<p>TODO: add images

<h2>Email

<p>For many use cases, third-party authentication of email will be sufficient. Occassionally, you'll want users to actual create passwords on your site. The scaffolded site does not include this setup, because:
<ul>
  <li>In order to securely accept passwords, you need to be running over SSL. Many users are not serving their sites over SSL.
  <li>While the email backend properly salts and hashes passwords, a compromised database could still be problematic. Again, we make no assumptions that Yesod users are following secure deployment practices.
  <li>You need to have a working system for sending email. Many web servers these days are not equipped to deal with all of the spam protection measures used by mail servers.
  <li>The example below will use the system's built-in sendmail executable. If you would like to avoid the hassle of dealing with an email server yourself, you can use Amazon SES. There is a package called \
    <a src="http://hackage.haskell.org/package/mime-mail-ses">mime-mail-ses
    # which provides a drop-in replacement for the sendmail code used below. This is the approach we use on the Haskellers.com site.
<p>But assuming you are able to meet these demands, and you want to have a separate password login specifically for your site, Yesod offers a built-in backend. It requires quite a bit of code to set up, since it needs to store passwords securely in the database and send a number of different emails to users (verify account, password retrieval, etc.).
<p>Let's have a look at a site that provides email authentication, storing passwords in a Persistent SQLite database.

<pre>#{code2}

<h2>Authorization

<p>Once you can authenticate your users, you can use their credentials to <i>authorize</i> requests. Authorization in Yesod is simple and declarative: most of the time, you just need to add the <code>authRoute</code> and <code>isAuthorized</code> methods to your Yesod typeclass instance. Let's see an example.</p>

<pre>#{code3}

<p><code>authRoute</code> should be your login page, almost always <code>AuthR LoginR</code>. <code>isAuthorized</code> is a function that takes two parameters: the requested route, and whether or not the request was a "write" request. You can actually change the meaning of what a write request is using the <code>isWriteRequest</code> method, but the out-of-the-box version follows RESTful principles: anything but a <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code> or <code>TRACE</code> request is a write request.
<p>What's convenient about the body of <code>isAuthorized</code> is that you can run any <code>Handler</code> code you want. This means you can:
<ul>
  <li>Access the filesystem (normal IO)
  <li>Lookup values in the database
  <li>Pull any session or request values you want
<p>Using these techniques, you can develop as sophisticated an authorization system as you like, or even tie into existing systems used by your organization.

<h2>Conclusion

<p>This chapter covered the basics of setting up user authentication, as well as how the built-in authorization functions provide a simple, declarative approach for users. While these are complicated concepts, with many approaches, Yesod should provide you with the building blocks you need to create your own customized auth solution.
