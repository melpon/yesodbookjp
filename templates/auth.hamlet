<h1>認証と認可

<p>
  認証（Authentication）と認可（Authorization）はよく似ているが、それらは全く別の概念だ。
  前者はユーザを識別する処理で、後者はユーザによってアクセス権が設定されているかを確認する処理だ。
  両者は単に認証（auth）と呼ばれることがあるため、これらの概念は混同されがちだ。

<p>
  Yesod はデフォルトで、OpenID, BrowserID, OAuth といったサードパーティによる認証をサポートしている。
  これらはユーザの信用情報（credential）を検証する外部のシステムである。Yesod アプリケーションは、この外部のシステムによる検証結果を信用して認証を行なう。
  さらに Yesod は、ユーザ名/パスワードの組み合わせや、メール/パスワードといった組み合わせによる認証もサポートしている。
  前者の方法は、ユーザにとっても、実装者にとっても簡単な保証しか行なわない。つまり、パスワードヒントは無いし、十分なセキュリティが担保されているわけでもない。
  後者の方法は、開発者がもっと細かく制御できるようになっている。

<p>
  認可においては、Yesod にはアドバンテージがある。
  Yesod には REST と型安全 URL があるため、シンプルかつ宣言的に作ることができる。
  さらに、認可のコードはすべて Haskell で書かれているため、言語の柔軟性を生かして、やりたいことを簡単に実現することができる。

<p>
  この章では、Yesod で認証と認可の書き方と、認証オプションの違いによるトレードオフについて議論する。

<h2>概要

<p>
  <a href="http://hackage.haskell.org/package/yesod-auth">yesod-auth
  \ パッケージは、様々な認証プラグインについて、統合されたインターフェースを提供している。
  これを使うために必要なバックエンドは、ユーザを一意に識別することができる文字列だけである。
  例えば OpenID では実際の OpenID である。BrowserID ではメールアドレスである。
  HashDB （パスワードをハッシュ化してデータベースに格納するプラグイン）ではユーザ名である。

<p>
  それぞれの認証プラグインは、それ自身がログイン機能を提供している。
  例えば外部サイトのパッシングトークン経由での認証や、メール/パスワードフォーム経由での認証などである。
  ログインが成功した後、認証プラグインはセッションに<code>AuthId</code>の値をセットする。
  この<code>AuthId</code>は通常、Persistent ID である。これはユーザをトラッキングし続けるために使われる。

<p>
  あるユーザの<code>AuthId</code>を取得する関数はいくつかある。
  最も一般的なのは、<code>maybeAuthId</code>, <code>requireAuthId</code>, <code>maybeAuth</code>, <code>requireAuth</code> である。
  require〜 系の関数は、ユーザがログインしていない場合にはログインページへとリダイレクトする。
  また、後ろ２つの 〜Auth 系の関数は、ID だけでなく、エンティティも取得する。

<p>Since all of the storage of <code>AuthId</code> is built on top of sessions, all of the rules from there apply. In particular, the data is stored in an encrypted, HMACed client cookie, which automatically times out after a certain configurable period of inactivity. Additionally, since there is no server-side component to sessions, logging out simply deletes the data from the session cookie; if a user reuses an older cookie value, the session will still be valid.
<p>On the flip side, authorization is handled by a few methods inside the <code>Yesod</code> typeclass. For every request, these methods are run to determine if access should be allowed, denied, or if the user needs to be authenticated. By default, these methods allow access for every request. Alternatively, you can implement authorization in a more ad-hoc way by adding calls to <code>requireAuth</code> and the like within individual handler functions, though this undermines many of the benefits of a declarative authorization system.

<h2>Authenticate Me

<p>Let's jump right in with an example of authentication.

<pre>#{code1}

<p>We'll start with the route declarations. First we declare our standard <code>RootR</code> route, and then we set up the authentication subsite. Remember that a subsite needs four parameters: the path to the subsite, the route name, the subsite name, and a function to get the subsite value. In other words, based on the line:

<pre>/auth AuthR Auth getAuth

<p>We need to have <code>getAuth :: MyAuthSite -> Auth</code>. While we haven't written that function ourselves, yesod-auth provides it automatically. With other subsites (like static files), we provide configuration settings in the subsite value, and therefore need to specify the get function. In the auth subsite, we specify these settings in a separate typeclass, <code>YesodAuth</code>.
<p>Why not use the subsite value? There are a number of settings we would like to give for an auth subsite, and doing so from a record type would be inconvenient. Also, since we want to have an <code>AuthId</code> associated type, a typeclass is more natural.
<p>On the flip side, why not use a typeclass for all subsites? It comes with a downside: you can then only have a single instance per site, disallowing serving different sets of static files from different routes. Also, the subsite value works better when we want to load data at app initialization.
<p>So what exactly goes in this YesodAuth instance? There are six required declarations:
<ul>
  <li><code>AuthId</code> is an associated type. This is the value <code>yesod-auth</code> will give you when you ask if a user is logged in (via <code>maybeAuthId</code> or <code>requireAuthId</code>). In our case, we're simply using <code>Text</code>, to store the raw identifier- email address in our case, as we'll soon see.
  <li><code>getAuthId</code> gets the actual <code>AuthId</code> from the <code>Creds</code> (credentials) data type. This type has three pieces of information: the authentication backend used (browserid or googleemail in our case), the actual identifier, and an associated list of arbitrary extra information. Each backend provides different extra information; see their docs for more information.
  <li><code>loginDest</code> gives the route to redirect to after a successful login.
  <li>Likewise, <code>logoutDest</code> gives the route to redirect to after a logout.
  <li><code>authPlugins</code> is a list of individual authentication backends to use. In our example, we're using BrowserID, which logs in via Mozilla's BrowserID system, and Google Email, which authenticates a user's email address using their Google account. The nice thing about these two backends is:
    <li>They require no set up, as opposed to Facebook or OAuth, which require setting up credentials.
    <li>They use email addresses as identifiers, which people are comfortable with, as opposed to OpenID, which uses a URL.
  <li><code>authHttpManager</code> gets an HTTP connection manager from the foundation type. This allow authentication backends which use HTTP connections (i.e., almost all third-party login systems) to share connections, avoiding the cost of restarting a TCP connection for each request.

<p>In our <code>RootR</code> handler, we have some simple links to the login and logout pages, depending on whether or not the user is logged in. Notice how we construct these subsite links: first we give the subsite route name (<code>AuthR</code>), followed by the route within the subsite (<code>LoginR</code> and <code>LogoutR</code>).
<p>The figures below show what the login process looks like from a user perspective.

<p>TODO: add images

<h2>Email

<p>For many use cases, third-party authentication of email will be sufficient. Occassionally, you'll want users to actual create passwords on your site. The scaffolded site does not include this setup, because:
<ul>
  <li>In order to securely accept passwords, you need to be running over SSL. Many users are not serving their sites over SSL.
  <li>While the email backend properly salts and hashes passwords, a compromised database could still be problematic. Again, we make no assumptions that Yesod users are following secure deployment practices.
  <li>You need to have a working system for sending email. Many web servers these days are not equipped to deal with all of the spam protection measures used by mail servers.
  <li>The example below will use the system's built-in sendmail executable. If you would like to avoid the hassle of dealing with an email server yourself, you can use Amazon SES. There is a package called \
    <a src="http://hackage.haskell.org/package/mime-mail-ses">mime-mail-ses
    # which provides a drop-in replacement for the sendmail code used below. This is the approach we use on the Haskellers.com site.
<p>But assuming you are able to meet these demands, and you want to have a separate password login specifically for your site, Yesod offers a built-in backend. It requires quite a bit of code to set up, since it needs to store passwords securely in the database and send a number of different emails to users (verify account, password retrieval, etc.).
<p>Let's have a look at a site that provides email authentication, storing passwords in a Persistent SQLite database.

<pre>#{code2}

<h2>Authorization

<p>Once you can authenticate your users, you can use their credentials to <i>authorize</i> requests. Authorization in Yesod is simple and declarative: most of the time, you just need to add the <code>authRoute</code> and <code>isAuthorized</code> methods to your Yesod typeclass instance. Let's see an example.</p>

<pre>#{code3}

<p><code>authRoute</code> should be your login page, almost always <code>AuthR LoginR</code>. <code>isAuthorized</code> is a function that takes two parameters: the requested route, and whether or not the request was a "write" request. You can actually change the meaning of what a write request is using the <code>isWriteRequest</code> method, but the out-of-the-box version follows RESTful principles: anything but a <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code> or <code>TRACE</code> request is a write request.
<p>What's convenient about the body of <code>isAuthorized</code> is that you can run any <code>Handler</code> code you want. This means you can:
<ul>
  <li>Access the filesystem (normal IO)
  <li>Lookup values in the database
  <li>Pull any session or request values you want
<p>Using these techniques, you can develop as sophisticated an authorization system as you like, or even tie into existing systems used by your organization.

<h2>Conclusion

<p>This chapter covered the basics of setting up user authentication, as well as how the built-in authorization functions provide a simple, declarative approach for users. While these are complicated concepts, with many approaches, Yesod should provide you with the building blocks you need to create your own customized auth solution.
