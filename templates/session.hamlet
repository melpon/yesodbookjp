<h1>セッション

<p>HTTP はステートレスプロトコルである。これはいくつかの場面では欠点となるが、同時に RESTful な Web 開発をする者にとってはプラスになる。

<!--
Sessions
 
HTTPは、ステートレスプロトコルである。
いくつかのビューでは欠点となるが、同時にRESTfulなWeb開発をする者にとってはプラスになる。
状態が画像から消されたとき、キャッシュが自動的に起こり、その他の多くのナイスな副作用が発生するアプリケーションをスケールさせることは簡単だ。あなたは汎用的に、Haskellのnon-mutable natureで多くを並列に描画できる。
 
できるかぎり、RESTfulアプリケーションはクライアントとの対話についての状態を格納することを回避するべきだ。しかし回避できない状況もある。ショッピングカートのような機能はクラシックな例だが、適切なログインハンドリングのような日常的なインタラクションは、セッションの適切な使い道によってより良くできる。 
 
このチャプターはYesodがどのようにセッションデータを格納するのか、どのようにこのデータにアクセスするのかと、セッションのほとんどを作るいくつかの特別なへルパ関数を説明する。
 
Clientsession
 
Yesodから最も早くスピンオフされたパッケージの一つはクライアントセッションだった。
このパッケージは、クライアントサイドのクッキーにデータを格納するために暗号化と署名を行なう。
暗号化は、データを調査することからユーザを防ぎ、署名はセッションがハイジャックや不正アクセスされないことを保証する。
 
それはおそらく、効率的な観点からクッキーへ格納するのは良くないアイデアだ 。
結局のところ、すべてのリクエストにデータを乗せなければならない、ということだ。 
ただし、実際はクライアントセッションはパフォーマンスにとても役に立つ。
 
サーバーサイドのデータ検索がリクエストのサービスのために要求されることは無い。
横にスケールするのが簡単だ。それぞれのリクエストはレスポンスを送るために必要な情報をすべての含んでいる。
 
過度のバンド幅のオーバーヘッドを回避するために、製品サイトは、それぞれのリクエストのためにセッションクッキーの転送のオーバーヘッドを回避するために、別のドメイン名から静的コンテンツをサーブすることができる。
 
セッションにメガバイト単位の情報を格納するのは良くないアイデアだ。
しかし大部分のセッションの実装は、すべてのセッションを送信する方法にすることを推奨する。
もし本当にユーだのための大きなストレージが必要になったのなら、セッションにはルックアップキーのみ格納し、実際のデータはデータベースに置くのがベストだ。 
 
クライアントセッションとの対話はすべて、Yesod内部でハンドルされているが、少しだけ振る舞いを調整できる場所がいくつかある。  
 
Controlling sessions
 
Yesodには、どのようにセッションが動作するかを制御するための関数が３つある。
encryptKey は使用する暗号化キーを返す。
デフォルトでは、ローカルファイルからこれを取るため、データベースがシャットダウンしてもセッションが続く。
このファイルは存在してなければ作られ、その際にはランダムデータでフィルされる。
そしてもしこの関数オーバーライドしてNothingを返すようにした場合、セッションは無効になる。
 
なぜセッションを無効にするのか。
セッションにはパフォーマンスのオーバーヘッドがある。
通常、このオーバーヘッドはミニマルだ。特にデータベースと比較するとなおさらだ。
しかしながら、とても基本的なタスクを処理するときには、このオーバーヘッドは無視できないものになる。
しかしセッションを無効にすることについて注意する必要がある。これはCSRFプロテクションの機能といったものも無効にしてしまう。
 
次の関数は  clientSessionDuration だ。この関数はセッションがアクティブになっている時間を分単位で指定する。デフォルトは 120 分(2時間)だ。
 
この値がセッションクッキーによって書き換えられる方法は２つある。一つはクッキー自身の期限が切れたことを確認したとき。もっと重要なのは、しかしながら、セッションの期限時間がセッションシグネチャの中にエンコードされていることだ。Yesodがシグネチャをデコードするときに、日付が過去であるかをチェックする。もしそうなら、セッションの値は無視する。
 
毎回Yesodはクライアントにレスポンスを送っている。そのレスポンスには新しい期限日時が書かれたアップデートされたセッションクッキーが入っている。この方法は、あなたがセッションの値自身を変更できなかったとしても、セッションはユーザがサイドのページを開いた場合にタイムアウトにならない。 
 
そしてこれは最後の関数、 sessionIpAddress をとてもナイスに導く。デフォルトでは、Yesodも、セッションハイジャック防止のためにクッキーの中にあるクライアントのIPアドレスをエンコードする。一般的に、
これは良いものだ。しかしながら、一部のISPは、それらのIPアドレスを書き換えるプロキシの後ろに、それらのユーザを配置することで知られている。そのため、セッション中ソースIPが何度か変わることがある。もしこうなり、sessionIpAddressを有効にしていた場合、ユーザのセッションはリセットされる。この設定をFalseにすれば、そのような環境でもセッションを継続することができる。ただし、セッションハイジャックされてしまう可能性がある。 

Session Operations
 
多くのフレームワークのように、Yesodのセッションはキーバリューストアになっている。ベースのセッションAPIは結局、３つの関数に集約される。lookupSessionはキーから(存在すれば)値を取得し、setSessionはキーと値をセットし、deleteSessionはキーを指定して値を削除する。
 
Messages
 
以前にほのめかしていたセッションの使い方の一つは、メッセージだ。それらはWeb開発の共通の問題を解決に導く。ユーザがPOSTリクエストを投げ、Webアプリは変更し、そしてWebアプリは新しいページへのリダイレクトと成功メッセージを同時に行いたい。(これはPost/Redirect/Getとして知られている)
 
Yesodはこれをとても簡単に解決する関数のペアを提供している。setMessageはセッションの中に値を格納し、getSessionはセッションに格納された最新の値を読み、古い値を削除する。そのため、二回表示されてしまうアクシデントが起こらない。
 
これはdefaultLayoutでgetMessageを呼び出すことを推奨する。これは任意の有効なメッセージが、ハンドラごとにgetMessageを呼び出したか思い出す必要なく、すぐにユーザに見せられるからだ。 
 
Ultimate Destination
 
Not to be confused with a horror film, このコンセプトはyesod-authの内部で使われる。ユーザが認証を必要とするページを要求してきたとする。もしユーザがログインしていない場合ユーザにログインページを出す必要がある。よくデザインされたWebアプリは、ログイン後、その時アクセスしようとしていたページに戻ってくるようになっている。我々はこれをultimate destinationと呼んでいる。
 
redirectUltDest は、ユーザに、セッション内のultimate destinationセットを送り、セッションからその値を削除する。It takes a default destination as well, in case there is no destination set. セッションを設定するために、３つのオプションがある。
 
setUltDestはdestに与えられたURLを設定する。
setUltDestCurrentは、destに現在のリクエストURLを設定する。
setUltDestRefererは、Refererヘッダベースのdestを設定する。
 
小さなサンプルアプリを見てみよう。これは、セッションにユーザ名を設定するユーザを許可し、他のルートからユーザ名を伝える。もしユーザ名が設定されていなかったら、ユーザを名前の設定ページにリダイレクトし、そのページに戻ってくるために現在のページをult destにセットする。
 
Summary
 
セッションは、状態を持てないというHTTPの制限を解決する一番の方法だ。しかし、これを逃げ道にしてはならない。つまり、Webアプリケーションの状態を持てない制限は良いことであり、できる限りこちらを使うべきである。
 
YesodのセッションAPIはとてもシンプルである。それはキーバリューストアになっていて、よくあるケースについては便利な関数が用意されている。これらを少ない労力で適切に使ったなら、セッションはWeb開発を控えめに支えてくれるだろう。 
-->
